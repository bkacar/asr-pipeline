"""
asrpipelinedb_api.py
This is the API for the asrpipeline Sqlite3 database.

Author: Victor Hanson-Smith
Email: victorhansonsmith@gmail.com
"""

import sqlite3 as lite
import os, re, sys
from log import *

def import_original_seq(con, shortname, sequence):
    """Returns the taxonID of the newly imported sequence."""
    cur = con.cursor()
    sql = "select count(*) from Taxa where shortname='" + shortname + "'"
    cur.execute(sql)
    count = cur.fetchone()[0]
    if count == 0:
        sql = "insert or replace into Taxa (fullname, shortname) VALUES('" + shortname + "','" + shortname + "')"
        cur.execute(sql)
        con.commit()
    
    taxonid = get_taxonid(con, shortname)

    #
    # to-do: continue here: I hardcoded in amino acids (1). Fix this.
    #    
    sql = "insert or replace into OriginalSequences (taxonid, sequence, datatype) VALUES(" + taxonid.__str__() + ",'" + sequence + "',1)"
    cur.execute(sql)
    con.commit()
    
    return taxonid

def import_aligned_seq(con, taxonid, almethodid, seq):
    cur = con.cursor()    
    sql = "insert or replace into AlignedSequences (taxonid, alsequence, almethod) VALUES("
    #
    # to-do: continue here: I hardcoded the datatype as amino acid (1)
    #
    sql += taxonid.__str__() + ",'" + seq + "'," + almethodid.__str__() + ")"
    cur.execute(sql)
    con.commit()
    
def import_alignment_method(con, name, exe):
    cur = con.cursor()
    sql = " insert or replace into AlignmentMethods(name, exe_path) VALUES("
    sql += "'" + name + "','" + exe + "')"
    cur.execute(sql)
    con.commit()

def get_taxonid(con, shortname):
    cur = con.cursor()
    sql = "select id from Taxa where shortname='" + shortname + "'"
    cur.execute(sql)
    x = cur.fetchall()
    if x.__len__() == 0:
        return None
    return x[0][0]

def get_taxon_name(con, taxonid):
    cur = con.cursor()
    sql = "select shortname from Taxa where id=" + taxonid.__str__()
    cur.execute(sql)
    x = cur.fetchall()
    if x.__len__() == 0:
        return None
    return x[0][0]

def get_aligned_seq(con, taxonid, almethodid):
    cur = con.cursor()
    sql = "select alsequence from AlignedSequences where taxonid=" + taxonid.__str__() + " and almethod=" + almethodid.__str__()
    cur.execute(sql)
    x = cur.fetchall()
    if x.__len__() == 0:
        return None
    return x[0][0]    

def get_sequences(con, almethod = None, sitesets = [], sites = [], taxagroups = [], relative_to_trimmed=False):
    """
    Returns a hash of taxa:sequences.
    con = the sqlite3 db
    almethod: if None, then returns all OriginalSequences, ignoring the value of siteset.
            : if a number N, then it returns only aligned sequences generated by the alignment method N.
    sitesets = the IDs of a SiteSet. Only sites corresponding to that set will be
        included in the output sequences. If [], then it will return all sites
    sites = a list of sites, of which only these sites should be included. You can't specify
        both sites and sitesets
    taxagroups: if [], then all possible sequences are returned,
                else, only sequences in the groups listed will be returned.
    relative_to_trimmed: If True, then the site numbers provided in sites should be interpreted
        as being relative to the aligned sequences trimmed to the seed sequences.
    """
    cur = con.cursor()
    
    sql = "select "
    if almethod == None:
        sql += " taxonid, sequence from OriginalSequences"
    else:
        if False == is_valid_almethod( con, almethod ):
            print "\n. Error (31): the alignment method", almethod, "is invalid."
            exit()
        sql += " taxonid, alsequence from AlignedSequences where almethod=" + almethod.__str__()

    if taxagroups != []:
        sql += " where taxonid in (select taxonid from GroupsTaxa "
        taxaids = []
        pieces = []
        for tgid in taxagroups:
            pieces.append( " where groupid=" + tgid )
        sql += " or ".join( pieces )
        sql += ")"
    
    cur.execute(sql)
    x = cur.fetchall()
    
    taxa_alseqs = {}
    for ii in x:
        taxonid = ii[0]
        seq = ii[1]
        taxa_alseqs[ taxonid ] = seq
    
    if sitesets != []:
        siteranges = []
        for id in sitesets:
            siteranges += get_sites_in_set (siteset)
        
        for taxon in taxa_alseqs:
            seq = taxa_alseqs[taxon]
            trimseq = ""
            for r in siteranges:
                trimseq += seq[ r[0]:(r[1]+1) ]
            taxa_alseqs[taxon] = trimseq
    
    elif sites != [] and almethod != None:

        startoffset = 0        
        if relative_to_trimmed == True:
            """We'll need to translate the site numbers in 'sites' to be relative
            to the trimmed-to-seed sequence."""
            
            sql = "select id from SiteSets where setname='seed'"
            cur.execute(sql)
            sitesetid = cur.fetchone()[0]
            sql = "select fromsite from SiteSetsAlignment where setid=" + sitesetid.__str__() + " and almethod=" + almethod.__str__()
            cur.execute(sql)
            x = cur.fetchall()
            seedstart = x[0][0]
            startoffset = seedstart
        
        for taxon in taxa_alseqs:
            seq = taxa_alseqs[taxon]
            trimseq = ""
            for s in sites:
                """Note, the -1 in the following array references allow us to translate a site
                number (which are 1-based) to a list index (which are 0-based)"""
                #print "asrpipelinedb.py 137:", almethod, s+startoffset-1, seq.__len__()
                trimseq += seq[s+startoffset-1]
            taxa_alseqs[taxon] = trimseq        
    
    return taxa_alseqs
        
    
def is_valid_almethod(con, methodid):
    cur = con.cursor()
    sql = "select count(*) from AlignmentMethods where id=" + methodid.__str__()
    cur.execute(sql)
    x = cur.fetchone()[0]
    if x > 0:
        return True
    else:
        return False

def get_taxaid_in_group(con, groupid):
    cur = con.cursor()
    sql = "select taxonid from GroupsTaxa where groupid=" + groupid
    cur.execute(sql)
    x = cur.fetchall()
    taxaids = []
    for ii in x:
        taxaids.append( ii[0] )
    return taxaids

def get_siteranges_in_set(con, sitesetid):
    """Returns a list of tuples [ (from,to), (from,to), etc. ]"""
    cur = con.cursor()
    sql = "select fromsite, tosite from SiteSetsAlignment where setid=" + sitesetid.__str__()
    cur.execute(sql)
    x = cur.fetchall()
    siteranges = []
    for ii in x:
        siteranges.append( (ii[0], ii[1]) )
    return siteranges

def write_fasta(seqs, fpath):
    fout = open(fpath, "w")
    for s in seqs:
        fout.write(">" + s + "\n")
        fout.write(seqs[s] + "\n")
    fout.close()
    
def write_phylip(seqs, ppath):
    """Sanity check: are all the sequences the same length?"""
    l = None
    for s in seqs:
        if l == None:
            l = seqs[s].__len__()
        elif seqs[s].__len__() != l:
            print "\n. Error. (115) You are trying to write a phylip-formatted alignment using a set of sequences that are different lengths."
            exit()
    """Okay, write the phylip file."""
    fout = open(ppath, "w")
    fout.write( seqs.__len__().__str__() + "   " + l.__str__() + "\n")
    for s in seqs:
        fout.write(s + "   " + seqs[s] + "\n")
    fout.close()

def get_alignmentsitescore(con, almethod, scoringmethoid):
    cur = con.cursor()
    sql = "select site, score from AlignmentSiteScores where almethodid=" + almethod.__str__() + " and scoringmethodid=" + scoringmethoid.__str__()
    cur.execute(sql)
    y = cur.fetchall()
    scores = {}
    for jj in y:
        scores[ jj[0] ] = jj[1]
    return scores

def get_zorro_thresholds(con):
    cur = con.cursor()
    sql = "select value from Settings where keyword='zorro_threshold'"
    cur.execute(sql)
    ts = []
    x = cur.fetchall()
    for ii in x:
        ts.append( ii[0] )
    return ts