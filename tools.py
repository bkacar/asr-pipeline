from configuration import *

def run_script(p, ap): 
    if ap.params["usempi"] == True:
        os.system( ap.params["mpirun_exe"] + " " + p)
    else:
        os.system("source " + p)

def get_runid(msa, model):
    return msa + "." + model

#
# The path to the trimmed PHYLIP alignment
#
def get_phylip_path(msa, ap):
    return "OUT." + msa + "/" + ap.params["geneid"] + "." + msa + ".trim.phylip"


def get_phylipfull_path(msa, ap):
    return "OUT." + msa + "/" + ap.params["geneid"] + "." + msa + ".full.phylip"

#
# The path to the full FASTA alignment
#
def get_fastafull_path(msa, ap):
    return "OUT." + msa + "/" + ap.params["geneid"] + "." + msa + ".full.fasta"

#
# The path to the trimmed FASTA alignment
#
def get_fasta_path(msa, ap):
    return "OUT." + msa + "/" + ap.params["geneid"] + "." + msa + ".trim.fasta"

#
# The path to log-L scores
#
def get_statspath(msa, model):
    return "OUT." + msa + "/RAxML_info." + get_runid(msa, model)

#
# The path to the RAxML ML tree
#
def get_raxml_treepath(DIR, runid):
    keyword = DIR_nick[DIR]
    return DIR + "/RAxML_bestTree." + runid


def get_ml_treepath(msa, runid):
    return "OUT." + msa + "/RAxML_bestTree." + runid

#
# The path to the ML tree with ALR branch support.  These ALR values are
# calculated from ALRT values, generated by PhyML
#
def get_alrt_treepath(msa, model, ap):
    runid = get_runid(msa, model)
    phylippath = get_phylip_path(msa, ap)
    return phylippath + "_phyml_tree_" + model + ".alrt.txt"

def get_alr_treepath(msa, model, ap):
    runid = get_runid(msa, model)
    phylippath = get_phylip_path(msa, ap)
    return phylippath + "_phyml_tree_" + model + ".alr.tre"

#
# Which tree should we use for ancestral reconstruction?
#
def get_asr_treepath(msa, runid):
    return get_ml_treepath(msa, runid)


def get_seed_sequence(msapath, seed):
    """msapath must be a phylip file.  Returns the seed sequence."""
    fin = open(msapath, "r")
    for l in fin.readlines():
        if l.startswith(seed):
            tokens = l.split()
            return tokens[1]

def get_ml_sequence(site_states_probs, start=0, stop=-1):
    mlseq = ""
    sites = site_states_probs.keys()
    sites.sort()
    for site in sites:
        if site < start:
            continue
        if site > stop and stop > 0:
            continue
        maxp = 0.0
        maxc = ""
        for c in site_states_probs[site]:
            #print site_states_probs[site][c]
            if site_states_probs[site][c] > maxp:
                maxp = site_states_probs[site][c]
                maxc = c
        if maxc != "-":
            mlseq += maxc
    return mlseq

def fasta_to_phylip(msapath):
    """The fasta file must be aligned."""
    ntaxa = 0
    fin = open(msapath, "r")
    for l in fin.readlines():
        if l.startswith(">"):
            ntaxa += 1
    fin.close()
    
    len = 0
    fin = open(msapath, "r")
    seq = ""
    count = 0
    for l in fin.readlines():
        if l.startswith(">"):
            count += 1
        elif count == 1:
            l = l.strip()
            seq += l
        elif count > 1:
            break
    fin.close()
    
    fin = open(msapath, "r")    
    outp = re.sub(".fasta", "", msapath)
    outp += ".phylip"
    fout = open(outp, "w")
    fout.write(ntaxa.__str__() + "  " + seq.__len__().__str__() + "\n")
    count = 0
    for l in fin.readlines():
        l = l.strip()
        if l.startswith(">"):
            if count > 0:
                fout.write("\n")
            taxa = re.sub(">", "", l)
            taxa = re.sub(" ", "", taxa)
            fout.write(taxa + "  ")
            count += 1
        else:
            fout.write(l)
    fout.write("\n")
    fout.close()
    fin.close()
            

def get_boundary_sites(msapath, ap):
    """msapath must be Phylip."""
    start_motif = ap.params["start_motif"] #"YQLI"
    end_motif = ap.params["end_motif"] #"MPFF"
    startsite = None
    endsite = None
    fin = open(msapath, "r")
    #print msapath, seed
    for l in fin.readlines():
        #print l
        if l.startswith(ap.params["seed_motif_seq"]):
            seq = l.split()[1]
            #print "tools 71:", seq
            # find the starting motif                                                                                               
            for i in range(0, seq.__len__()):
                if seq[i] == start_motif[0]:
                    here = ""
                    j = i
                    while here.__len__() < start_motif.__len__() and j < seq.__len__():
                        if seq[j] != "-":
                            here += seq[j]
                        j += 1
                    if here  == start_motif:
                        startsite = i + 1
                        #print here, seq[startsite-1:(startsite-1)+4]                     
                                          
                        break
            for i in range(i, seq.__len__()):
                if seq[i] == end_motif[0]:
                    here = ""
                    j = i
                    while here.__len__() < end_motif.__len__() and j < seq.__len__():
                        if seq[j] != "-":
                            here += seq[j]
                        j += 1
                    #print here, end_motif                                                
                                          
                    if here  == end_motif:
                        endsite = j
                        #print seq[endsite-1:(endsite-1)+3]
                        break
    fin.close()
    return [startsite, endsite]
